<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/Publisher/Builder/DocBuilder.js | ESDoc API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/h13i32maru/esdoc" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/ASTDocBuilder.js~ASTDocBuilder.html">ASTDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Util/ASTUtil.js~ASTUtil.html">ASTUtil</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/AbstractDoc.js~AbstractDoc.html">AbstractDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/AssignmentDoc.js~AssignmentDoc.html">AssignmentDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/ClassDoc.js~ClassDoc.html">ClassDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/ClassDocBuilder.js~ClassDocBuilder.html">ClassDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Parser/CommentParser.js~CommentParser.html">CommentParser</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/CoverageBuilder.js~CoverageBuilder.html">CoverageBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/DocBuilder.js~DocBuilder.html">DocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Factory/DocFactory.js~DocFactory.html">DocFactory</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/DocResolver.js~DocResolver.html">DocResolver</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/ESDoc.js~ESDoc.html">ESDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/ESDocCLI.js~ESDocCLI.html">ESDocCLI</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Parser/ESParser.js~ESParser.html">ESParser</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/ExternalDoc.js~ExternalDoc.html">ExternalDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/FileDoc.js~FileDoc.html">FileDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/FileDocBuilder.js~FileDocBuilder.html">FileDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/FunctionDoc.js~FunctionDoc.html">FunctionDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/IdentifiersDocBuilder.js~IdentifiersDocBuilder.html">IdentifiersDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/IndexDocBuilder.js~IndexDocBuilder.html">IndexDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Util/InvalidCodeLogger.js~InvalidCodeLogger.html">InvalidCodeLogger</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/MemberDoc.js~MemberDoc.html">MemberDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/MethodDoc.js~MethodDoc.html">MethodDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Util/NamingUtil.js~NamingUtil.html">NamingUtil</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Parser/ParamParser.js~ParamParser.html">ParamParser</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Util/PathResolver.js~PathResolver.html">PathResolver</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/SearchIndexBuilder.js~SearchIndexBuilder.html">SearchIndexBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/SingleDocBuilder.js~SingleDocBuilder.html">SingleDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/SourceDocBuilder.js~SourceDocBuilder.html">SourceDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/StaticFileBuilder.js~StaticFileBuilder.html">StaticFileBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/TestDoc.js~TestDoc.html">TestDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/TestDocBuilder.js~TestDocBuilder.html">TestDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Factory/TestDocFactory.js~TestDocFactory.html">TestDocFactory</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/TestFileDoc.js~TestFileDoc.html">TestFileDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Publisher/Builder/TestFileDocBuilder.js~TestFileDocBuilder.html">TestFileDocBuilder</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/TypedefDoc.js~TypedefDoc.html">TypedefDoc</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Doc/VariableDoc.js~VariableDoc.html">VariableDoc</a></span></li>
</ul>
</div>



<div data-ice="functionWrap">
  <h2><a href="function/">Function</a></h2>
  <ul>
    
  <li data-ice="functionDoc"><span><a href="function/index.html#static-function-dateForUTC">dateForUTC</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-markdown">markdown</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-publish">publish</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-shorten">shorten</a></span></li>
</ul>
</div>

<div data-ice="variableWrap">
  <h2><a href="variable/">Variable</a></h2>
  <ul>
    
  <li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-invalidCodeLogger">invalidCodeLogger</a></span></li>
</ul>
</div>

<div data-ice="typedefWrap">
  <h2><a href="typedef/">Typedef</a></h2>
  <ul>
    
  <li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-AST">AST</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-ASTNode">ASTNode</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-CoverageObject">CoverageObject</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-DocObject">DocObject</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-DocTypedef">DocTypedef</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-ESDocCLIArgv">ESDocCLIArgv</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-ESDocConfig">ESDocConfig</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-IceCap">IceCap</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-IceCapInstanceTypedef">IceCapInstanceTypedef</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-NPMPackageObject">NPMPackageObject</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-PackageTypedef">PackageTypedef</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-ParsedParam">ParsedParam</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-Taffy">Taffy</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-TaffyCursor">TaffyCursor</a></span></li>
<li data-ice="typedefDoc"><span><a href="typedef/index.html#static-typedef-Tag">Tag</a></span></li>
</ul>
</div>


</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Publisher/Builder/DocBuilder.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">import fs from &apos;fs&apos;;
import path from &apos;path&apos;;
import escape from &apos;escape-html&apos;;
import IceCap from &apos;ice-cap&apos;;
import {shorten} from &apos;./util.js&apos;;
import DocResolver from &apos;./DocResolver.js&apos;;

/**
 * Builder base class.
 */
export default class DocBuilder {
  /**
   * create instance.
   * @param {Taffy} data - doc object database.
   * @param {ESDocConfig} config - esdoc config is used build output.
   */
  constructor(data, config) {
    this._data = data;
    this._config = config;
    new DocResolver(this).resolve();
  }

  /**
   * execute building output.
   * @abstract
   * @param {function} callback - is called with some data.
   */
  exec(callback) {
  }

  /**
   * find doc object.
   * @param {...Object} cond - find condition.
   * @returns {DocObject[]} found doc objects.
   * @private
   */
  _find(...cond) {
    return this._orderedFind(null, ...cond);
  }

  /**
   * fuzzy find doc object by name.
   * - equal with longname
   * - equal with name
   * - include in longname
   * - include in ancestor
   *
   * @param {string} name - target identifier name.
   * @param {string} [kind] - target kind.
   * @returns {DocObject[]} found doc objects.
   * @private
   */
  _findByName(name, kind = null) {
    let docs;

    if (kind) {
      docs = this._orderedFind(null, {longname: name, kind: kind});
    } else {
      docs = this._orderedFind(null, {longname: name});
    }
    if (docs.length) return docs;

    if (kind) {
      docs = this._orderedFind(null, {name: name, kind: kind});
    } else {
      docs = this._orderedFind(null, {name: name});
    }
    if (docs.length) return docs;

    let regexp = new RegExp(`[~]\\${name}$`); // if name is `*`, need to escape.
    if (kind) {
      docs = this._orderedFind(null, {longname: {regex: regexp}, kind: kind});
    } else {
      docs = this._orderedFind(null, {longname: {regex: regexp}});
    }
    if (docs.length) return docs;

    // inherited method?
    let matched = name.match(/(.*)[.#](.*)$/); // instance method(Foo#bar) or static method(Foo.baz)
    if (matched) {
      let parent = matched[1];
      let childName = matched[2];
      let parentDoc = this._findByName(parent, &apos;class&apos;)[0];
      if (parentDoc &amp;&amp; parentDoc._custom_extends_chains) {
        for (let superLongname of parentDoc._custom_extends_chains) {
          let docs = this._find({memberof: superLongname, name: childName});
          if (docs.length) return docs;
        }
      }
    }

    return [];
  }

  /**
   * find doc objects that is ordered.
   * @param {string} order - doc objects order(``column asec`` or ``column desc``).
   * @param {...Object} cond - condition objects
   * @returns {DocObject[]} found doc objects.
   * @private
   */
  _orderedFind(order, ...cond) {
    let data = this._data(...cond);

    if (order) {
      return data.order(order + &apos;, name asec&apos;).map(v =&gt; v);
    } else {
      return data.order(&apos;name asec&apos;).map(v =&gt; v);
    }
  }

  /**
   * read html template.
   * @param {string} fileName - template file name.
   * @return {string} html of template.
   * @private
   */
  _readTemplate(fileName) {
    let filePath = path.resolve(__dirname, `./template/${fileName}`);
    return fs.readFileSync(filePath, {encoding: &apos;utf-8&apos;});
  }

  /**
   * get target&apos;s essential info.
   * @returns {{title: string, version: string, url: string}}
   * @private
   */
  _getInfo() {
    let config = this._config;
    let packageObj = {};
    if (config.package) {
      let packagePath = config.package;
      let json = fs.readFileSync(packagePath, {encoding: &apos;utf-8&apos;});
      packageObj = JSON.parse(json);
    }

    let indexInfo = {
      title: config.title || packageObj.name,
      //desc: config.description || packageObj.description,
      version: config.version || packageObj.version,
      //url: config.url || packageObj.repository ? packageObj.repository.url : &apos;&apos;
      url: packageObj.repository ? packageObj.repository.url : &apos;&apos;
    };

    if (indexInfo.url.indexOf(&apos;git@github.com:&apos;) === 0) {
      let matched = indexInfo.url.match(/^git@github\.com:(.*)\.git$/);
      if (matched &amp;&amp; matched[1]) {
        indexInfo.url = `https://github.com/${matched[1]}`;
      }
    }

    return indexInfo;
  }

  /**
   * build common layout output.
   * @return {IceCap} layout output.
   * @private
   */
  _buildLayoutDoc() {
    let info = this._getInfo();

    let ice = new IceCap(this._readTemplate(&apos;layout.html&apos;), {autoClose: false});

    ice.text(&apos;esdocVersion&apos;, `(${this._config._esdocVersion})`);

    if (info.url) {
      ice.attr(&apos;repoURL&apos;, &apos;href&apos;, info.url);
      if (info.url.match(new RegExp(&apos;^https?://github.com/&apos;))) {
        ice.attr(&apos;repoURL&apos;, &apos;class&apos;, &apos;repo-url-github&apos;);
      }
    } else {
      ice.drop(&apos;repoURL&apos;);
    }

    ice.drop(&apos;testLink&apos;, !this._config.test);

    // see StaticFileBuilder#exec
    ice.loop(&apos;userScript&apos;, this._config.scripts || [], (i, userScript, ice)=&gt;{
      let name = `user/script/${i}-${path.basename(userScript)}`;
      ice.attr(&apos;userScript&apos;, &apos;src&apos;, name);
    });

    ice.loop(&apos;userStyle&apos;, this._config.styles || [], (i, userStyle, ice)=&gt;{
      let name = `user/css/${i}-${path.basename(userStyle)}`;
      ice.attr(&apos;userStyle&apos;, &apos;href&apos;, name);
    });

    ice.load(&apos;nav&apos;, this._buildNavDoc());
    return ice;
  }

  /**
   * build common navigation output.
   * @return {IceCap} navigation output.
   * @private
   */
  _buildNavDoc() {
    let html = this._readTemplate(&apos;nav.html&apos;);
    let ice = new IceCap(html);

    // class
    let classDocs = this._find({kind: &apos;class&apos;, interface: false});
    ice.drop(&apos;classWrap&apos;, !classDocs.length);
    ice.loop(&apos;classDoc&apos;, classDocs, (i, classDoc, ice)=&gt;{
      ice.load(&apos;classDoc&apos;, this._buildDocLinkHTML(classDoc.longname));
    });

    // interface
    let interfaceDocs = this._find({kind: &apos;class&apos;, interface: true});
    ice.drop(&apos;interfaceWrap&apos;, !interfaceDocs.length);
    ice.loop(&apos;interfaceDoc&apos;, interfaceDocs, (i, interfaceDoc, ice)=&gt;{
      ice.load(&apos;interfaceDoc&apos;, this._buildDocLinkHTML(interfaceDoc.longname));
    });

    // function
    let functionDocs = this._find({kind: &apos;function&apos;});
    ice.drop(&apos;functionWrap&apos;, !functionDocs.length);
    ice.loop(&apos;functionDoc&apos;, functionDocs, (i, functionDoc, ice)=&gt;{
      ice.load(&apos;functionDoc&apos;, this._buildDocLinkHTML(functionDoc.longname));
    });

    // variable
    let variableDocs = this._find({kind: &apos;variable&apos;});
    ice.drop(&apos;variableWrap&apos;, !variableDocs.length);
    ice.loop(&apos;variableDoc&apos;, variableDocs, (i, variableDoc, ice)=&gt;{
      ice.load(&apos;variableDoc&apos;, this._buildDocLinkHTML(variableDoc.longname));
    });

    // typedef
    let typedefDocs = this._find({kind: &apos;typedef&apos;});
    ice.drop(&apos;typedefWrap&apos;, !typedefDocs.length);
    ice.loop(&apos;typedefDoc&apos;, typedefDocs, (i, typedefDoc, ice)=&gt;{
      ice.load(&apos;typedefDoc&apos;, this._buildDocLinkHTML(typedefDoc.longname));
    });

    // external
    let externalDocs = this._find({kind: &apos;external&apos;}).filter(v =&gt; !v.builtinExternal);
    ice.drop(&apos;externalWrap&apos;, !externalDocs.length);
    ice.loop(&apos;externalDoc&apos;, externalDocs, (i, externalDoc, ice)=&gt;{
      ice.load(&apos;externalDoc&apos;, this._buildDocLinkHTML(externalDoc.longname));
    });

    return ice;
  }

  /**
   * find doc object for each access.
   * @param {DocObject} doc - parent doc object.
   * @param {string} kind - kind property condition.
   * @param {boolean} isStatic - static property condition
   * @returns {Array[]} found doc objects.
   * @property {Array[]} 0 - [&apos;Public&apos;, DocObject[]]
   * @property {Array[]} 1 - [&apos;Protected&apos;, DocObject[]]
   * @property {Array[]} 2 - [&apos;Private&apos;, DocObject[]]
   * @private
   */
  _findAccessDocs(doc, kind, isStatic = true) {
    let cond = {kind, static: isStatic};

    if (doc) cond.memberof = doc.longname;

    switch (kind) {
      case &apos;class&apos;:
        cond.interface = false;
        break;
      case &apos;interface&apos;:
        cond.kind = &apos;class&apos;;
        cond.interface = true;
        break;
      case &apos;member&apos;:
        cond.kind = [&apos;member&apos;, &apos;get&apos;, &apos;set&apos;];
        break;
    }

    let publicDocs = this._find(cond, {access: &apos;public&apos;});
    let protectedDocs = this._find(cond, {access: &apos;protected&apos;});
    let privateDocs = this._find(cond, {access: &apos;private&apos;});
    let accessDocs = [[&apos;Public&apos;, publicDocs], [&apos;Protected&apos;, protectedDocs], [&apos;Private&apos;, privateDocs]];

    return accessDocs;
  }

  /**
   * build summary output html by parent doc.
   * @param {DocObject} doc - parent doc object.
   * @param {string} kind - target kind property.
   * @param {string} title - summary title.
   * @param {boolean} [isStatic=true] - target static property.
   * @returns {string} html of summary.
   * @private
   */
  _buildSummaryHTML(doc, kind, title, isStatic = true) {
    let accessDocs = this._findAccessDocs(doc, kind, isStatic);
    let html = &apos;&apos;;
    for (let accessDoc of accessDocs) {
      let docs = accessDoc[1];
      if (!docs.length) continue;

      let prefix = &apos;&apos;;
      if (docs[0].static) prefix = &apos;Static &apos;;
      let _title = `${prefix}${accessDoc[0]} ${title}`;

      let result = this._buildSummaryDoc(docs, _title);
      if (result) {
        html += result.html;
      }
    }

    return html;
  }

  /**
   * build summary output html by docs.
   * @param {DocObject[]} docs - target docs.
   * @param {string} title - summary title.
   * @param {boolean} innerLink - if true, link in summary is inner link.
   * @return {IceCap} summary output.
   * @private
   */
  _buildSummaryDoc(docs, title, innerLink) {
    if (docs.length === 0) return;

    let ice = new IceCap(this._readTemplate(&apos;summary.html&apos;));

    ice.text(&apos;title&apos;, title);
    ice.loop(&apos;target&apos;, docs, (i, doc, ice)=&gt;{
      ice.text(&apos;generator&apos;, doc.generator ? &apos;*&apos; : &apos;&apos;);
      ice.load(&apos;name&apos;, this._buildDocLinkHTML(doc.longname, null, innerLink, doc.kind));
      ice.load(&apos;signature&apos;, this._buildSignatureHTML(doc));
      ice.load(&apos;description&apos;, shorten(doc));
      ice.text(&apos;abstract&apos;, doc.abstract ? &apos;abstract&apos; : &apos;&apos;);
      ice.text(&apos;access&apos;, doc.access);
      if ([&apos;get&apos;, &apos;set&apos;].includes(doc.kind)) {
        ice.text(&apos;kind&apos;, doc.kind);
      } else {
        ice.drop(&apos;kind&apos;);
      }

      if ([&apos;member&apos;, &apos;method&apos;, &apos;get&apos;, &apos;set&apos;].includes(doc.kind)) {
        ice.text(&apos;static&apos;, doc.static ? &apos;static&apos; : &apos;&apos;);
      } else {
        ice.drop(&apos;static&apos;);
      }

      ice.text(&apos;since&apos;, doc.since);
      ice.load(&apos;deprecated&apos;, this._buildDeprecatedHTML(doc));
      ice.load(&apos;experimental&apos;, this._buildExperimentalHTML(doc));
      ice.text(&apos;version&apos;, doc.version);
    });

    return ice;
  }

  /**
   * build detail output html by parent doc.
   * @param {DocObject} doc - parent doc object.
   * @param {string} kind - target kind property.
   * @param {string} title - detail title.
   * @param {boolean} [isStatic=true] - target static property.
   * @returns {string} html of detail.
   * @private
   */
  _buildDetailHTML(doc, kind, title, isStatic = true) {
    let accessDocs = this._findAccessDocs(doc, kind, isStatic);
    let html = &apos;&apos;;
    for (let accessDoc of accessDocs) {
      let docs = accessDoc[1];
      if (!docs.length) continue;

      let prefix = &apos;&apos;;
      if (docs[0].static) prefix = &apos;Static &apos;;
      let _title = `${prefix}${accessDoc[0]} ${title}`;

      let result = this._buildDetailDocs(docs, _title);
      if (result) html += result.html;
    }

    return html;
  }

  /**
   * build detail output html by docs.
   * @param {DocObject[]} docs - target docs.
   * @param {string} title - detail title.
   * @return {IceCap} detail output.
   * @private
   */
  _buildDetailDocs(docs, title) {
    let ice = new IceCap(this._readTemplate(&apos;details.html&apos;));

    ice.text(&apos;title&apos;, title);
    ice.drop(&apos;title&apos;, !docs.length);

    ice.loop(&apos;detail&apos;, docs, (i, doc, ice)=&gt;{
      let scope = doc.static ? &apos;static&apos; : &apos;instance&apos;;
      ice.attr(&apos;anchor&apos;, &apos;id&apos;, `${scope}-${doc.kind}-${doc.name}`);
      ice.text(&apos;generator&apos;, doc.generator ? &apos;*&apos; : &apos;&apos;);
      ice.text(&apos;name&apos;, doc.name);
      ice.load(&apos;signature&apos;, this._buildSignatureHTML(doc));
      ice.load(&apos;description&apos;, doc.description);
      ice.text(&apos;abstract&apos;, doc.abstract ? &apos;abstract&apos; : &apos;&apos;);
      ice.text(&apos;access&apos;, doc.access);
      if ([&apos;get&apos;, &apos;set&apos;].includes(doc.kind)) {
        ice.text(&apos;kind&apos;, doc.kind);
      } else {
        ice.drop(&apos;kind&apos;);
      }
      if (doc.export &amp;&amp; doc.importPath &amp;&amp; doc.importStyle) {
        let link = this._buildFileDocLinkHTML(doc, doc.importPath);
        ice.into(&apos;importPath&apos;, `import ${doc.importStyle} from &apos;${link}&apos;`, (code, ice)=&gt;{
          ice.load(&apos;importPathCode&apos;, code);
        });
      } else {
        ice.drop(&apos;importPath&apos;);
      }

      if ([&apos;member&apos;, &apos;method&apos;, &apos;get&apos;, &apos;set&apos;].includes(doc.kind)) {
        ice.text(&apos;static&apos;, doc.static ? &apos;static&apos; : &apos;&apos;);
      } else {
        ice.drop(&apos;static&apos;);
      }

      ice.load(&apos;source&apos;, this._buildFileDocLinkHTML(doc, &apos;source&apos;));
      ice.text(&apos;since&apos;, doc.since, &apos;append&apos;);
      ice.load(&apos;deprecated&apos;, this._buildDeprecatedHTML(doc));
      ice.load(&apos;experimental&apos;, this._buildExperimentalHTML(doc));
      ice.text(&apos;version&apos;, doc.version, &apos;append&apos;);
      ice.load(&apos;see&apos;, this._buildDocsLinkHTML(doc.see), &apos;append&apos;);
      ice.load(&apos;todo&apos;, this._buildDocsLinkHTML(doc.todo), &apos;append&apos;);
      ice.load(&apos;override&apos;, this._buildOverrideMethod(doc));

      if ([&apos;method&apos;, &apos;constructor&apos;, &apos;function&apos;].indexOf(doc.kind) !== -1) {
        ice.load(&apos;properties&apos;, this._buildProperties(doc.params, &apos;Params:&apos;));
      } else {
        ice.load(&apos;properties&apos;, this._buildProperties(doc.properties, &apos;Properties:&apos;));
      }

      // return
      if (doc.return) {
        ice.load(&apos;returnDescription&apos;, doc.return.description);
        let typeNames = [];
        for (let typeName of doc.return.types) {
          typeNames.push(this._buildTypeDocLinkHTML(typeName));
        }
        if (typeof doc.return.nullable === &apos;boolean&apos;) {
          let nullable = doc.return.nullable;
          ice.load(&apos;returnType&apos;, typeNames.join(&apos; | &apos;) + ` (nullable: ${nullable})`);
        } else {
          ice.load(&apos;returnType&apos;, typeNames.join(&apos; | &apos;));
        }

        ice.load(&apos;returnProperties&apos;, this._buildProperties(doc.properties, &apos;Return Properties:&apos;));
      } else {
        ice.drop(&apos;returnParams&apos;);
      }

      // throws
      if (doc.throws) {
        ice.loop(&apos;throw&apos;, doc.throws, (i, exceptionDoc, ice)=&gt;{
          ice.load(&apos;throwName&apos;, this._buildDocLinkHTML(exceptionDoc.types[0]));
          ice.load(&apos;throwDesc&apos;, exceptionDoc.description);
        });
      } else {
        ice.drop(&apos;throwWrap&apos;);
      }

      // fires
      if (doc.emits) {
        ice.loop(&apos;emit&apos;, doc.emits, (i, emitDoc, ice)=&gt;{
          ice.load(&apos;emitName&apos;, this._buildDocLinkHTML(emitDoc.types[0]));
          ice.load(&apos;emitDesc&apos;, emitDoc.description);
        });
      } else {
        ice.drop(&apos;emitWrap&apos;);
      }

      // listens
      if (doc.listens) {
        ice.loop(&apos;listen&apos;, doc.listens, (i, listenDoc, ice)=&gt;{
          ice.load(&apos;listenName&apos;, this._buildDocLinkHTML(listenDoc.types[0]));
          ice.load(&apos;listenDesc&apos;, listenDoc.description);
        });
      } else {
        ice.drop(&apos;listenWrap&apos;);
      }

      // example
      ice.into(&apos;example&apos;, doc.examples, (examples, ice)=&gt;{
        ice.loop(&apos;exampleDoc&apos;, examples, (i, exampleDoc, ice)=&gt;{
          ice.text(&apos;exampleCode&apos;, exampleDoc);
        });
      });

      // tests
      ice.into(&apos;tests&apos;, doc._custom_tests, (tests, ice)=&gt;{
        ice.loop(&apos;test&apos;, tests, (i, test, ice)=&gt;{
          let testDoc = this._find({longname: test})[0];
          ice.load(&apos;test&apos;, this._buildFileDocLinkHTML(testDoc, testDoc.testFullDescription));
        });
      });
    });

    return ice;
  }

  /**
   * get output html page title. use ``title`` in {@link ESDocConfig}.
   * @param {DocObject} doc - target doc object.
   * @returns {string} page title.
   * @private
   */
  _getTitle(doc = &apos;&apos;) {
    let name = doc.name || doc.toString();

    if (!name) {
      if (this._config.title) {
        return `${this._config.title} API Document`;
      } else {
        return &apos;API Document&apos;;
      }
    }

    if (this._config.title) {
      return `${name} | ${this._config.title} API Document`;
    } else {
      return `${name} | API Document`;
    }
  }

  /**
   * get base url html page. it is used html base tag.
   * @param {string} fileName - output file path.
   * @returns {string} base url.
   * @private
   */
  _getBaseUrl(fileName) {
    let baseUrl = &apos;../&apos;.repeat(fileName.split(&apos;/&apos;).length - 1);
    return baseUrl;
  }

  /**
   * gat url of output html page.
   * @param {DocObject} doc - target doc object.
   * @returns {string} url of output html. it is relative path from output root dir.
   * @private
   */
  _getURL(doc) {
    let inner = false;
    if ([&apos;variable&apos;, &apos;function&apos;, &apos;member&apos;, &apos;typedef&apos;, &apos;method&apos;, &apos;constructor&apos;, &apos;get&apos;, &apos;set&apos;].includes(doc.kind)) {
      inner = true
    }

    if (inner) {
      let scope = doc.static ? &apos;static&apos; : &apos;instance&apos;;
      let fileName = this._getOutputFileName(doc);
      return `${fileName}#${scope}-${doc.kind}-${doc.name}`;
    } else {
      let fileName = this._getOutputFileName(doc);
      return fileName;
    }
  }

  /**
   * get file name of output html page.
   * @param {DocObject} doc - target doc object.
   * @returns {string} file name.
   * @private
   */
  _getOutputFileName(doc) {
    switch (doc.kind) {
      case &apos;variable&apos;:
        return &apos;variable/index.html&apos;;
      case &apos;function&apos;:
        return &apos;function/index.html&apos;;
      case &apos;member&apos;: // fall
      case &apos;method&apos;: // fall
      case &apos;constructor&apos;: // fall
      case &apos;set&apos;: // fall
      case &apos;get&apos;: // fal
        let parentDoc = this._find({longname: doc.memberof})[0];
        return this._getOutputFileName(parentDoc);
      case &apos;external&apos;:
        return &apos;external/index.html&apos;;
      case &apos;typedef&apos;:
        return &apos;typedef/index.html&apos;;
      case &apos;class&apos;:
        return `class/${doc.longname}.html`;
      case &apos;file&apos;:
        return `file/${doc.longname}.html`;
      case &apos;testFile&apos;:
        return `test-file/${doc.longname}.html`;
      case &apos;testDescribe&apos;:
        return `test.html`;
      case &apos;testIt&apos;:
        return `test.html`;
      default:
        throw new Error(&apos;DocBuilder: can not resolve file name.&apos;);
    }
  }

  /**
   * build html link to file page.
   * @param {DocObject} doc - target doc object.
   * @param {string} text - link text.
   * @returns {string} html of link.
   * @private
   */
  _buildFileDocLinkHTML(doc, text = null) {
    if (!doc) return &apos;&apos;;

    let fileDoc;
    if (doc.kind === &apos;file&apos; || doc.kind === &apos;testFile&apos;) {
      fileDoc = doc;
    } else {
      let filePath = doc.longname.split(&apos;~&apos;)[0];
      fileDoc = this._find({kind: [&apos;file&apos;, &apos;testFile&apos;], longname: filePath})[0];
    }

    if (!fileDoc) return &apos;&apos;;

    if (!text) text = fileDoc.name;

    if (doc.kind === &apos;file&apos; || doc.kind === &apos;testFile&apos;) {
      return `&lt;span&gt;&lt;a href=&quot;${this._getURL(fileDoc)}&quot;&gt;${text}&lt;/a&gt;&lt;/span&gt;`;
    } else {
      return `&lt;span&gt;&lt;a href=&quot;${this._getURL(fileDoc)}#lineNumber${doc.lineNumber}&quot;&gt;${text}&lt;/a&gt;&lt;/span&gt;`;
    }
  }

  /**
   * build html link of type.
   * @param {string} typeName - type name(e.g. ``number[]``, ``Map&lt;number, string}``)
   * @returns {string} html of link.
   * @private
   * @todo re-implement with parser combinator.
   */
  _buildTypeDocLinkHTML(typeName) {
    // e.g. number[]
    let matched = typeName.match(/^(.*?)\[\]$/);
    if (matched) {
      typeName = matched[1];
      return `&lt;span&gt;${this._buildDocLinkHTML(typeName, typeName)}&lt;span&gt;[]&lt;/span&gt;&lt;/span&gt;`;
    }

    // e.g. function(a: number, b: string): boolean
    matched = typeName.match(/function\((.*?)\)(.*)/);
    if (matched) {
      let functionLink = this._buildDocLinkHTML(&apos;function&apos;);
      if (!matched[1] &amp;&amp; !matched[2]) return `&lt;span&gt;${functionLink}&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;`;

      let innerTypes = [];
      if (matched[1]) {
        // bad hack: Map.&lt;string, boolean&gt; =&gt; Map.&lt;string\Z boolean&gt;
        // bad hack: {a: string, b: boolean} =&gt; {a\Y string\Z b\Y boolean}
        let inner = matched[1]
          .replace(/&lt;.*?&gt;/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;))
          .replace(/{.*?}/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;).replace(/:/g, &apos;\\Y&apos;));
        innerTypes = inner.split(&apos;,&apos;).map((v)=&gt;{
          let tmp = v.split(&apos;:&apos;).map((v)=&gt; v.trim());
          let paramName = tmp[0];
          let typeName = tmp[1].replace(/\\Z/g, &apos;,&apos;).replace(/\\Y/g, &apos;:&apos;);
          return `${paramName}: ${this._buildTypeDocLinkHTML(typeName)}`;
        });
      }

      let returnType = &apos;&apos;;
      if (matched[2]) {
        let type = matched[2].split(&apos;:&apos;)[1];
        if (type) returnType = &apos;: &apos; + this._buildTypeDocLinkHTML(type.trim());
      }

      return `&lt;span&gt;${functionLink}&lt;span&gt;(${innerTypes.join(&apos;, &apos;)})&lt;/span&gt;${returnType}&lt;/span&gt;`;
    }

    // e.g. {a: number, b: string}
    matched = typeName.match(/^\{(.*?)\}$/);
    if (matched) {
      if (!matched[1]) return &apos;{}&apos;;

      // bad hack: Map.&lt;string, boolean&gt; =&gt; Map.&lt;string\Z boolean&gt;
      // bad hack: {a: string, b: boolean} =&gt; {a\Y string\Z b\Y boolean}
      let inner = matched[1]
        .replace(/&lt;.*?&gt;/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;))
        .replace(/{.*?}/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;).replace(/:/g, &apos;\\Y&apos;));
      let innerTypes = inner.split(&apos;,&apos;).map((v)=&gt;{
        let tmp = v.split(&apos;:&apos;).map((v)=&gt; v.trim());
        let paramName = tmp[0];
        let typeName = tmp[1].replace(/\\Z/g, &apos;,&apos;).replace(/\\Y/g, &apos;:&apos;);
        return `${paramName}: ${this._buildTypeDocLinkHTML(typeName)}`;
      });

      return `{${innerTypes.join(&apos;, &apos;)}}`;
    }

    // e.g. Map&lt;number, string&gt;
    matched = typeName.match(/^(.*?)\.?&lt;(.*?)&gt;$/);
    if (matched) {
      let mainType = matched[1];
      // bad hack: Map.&lt;string, boolean&gt; =&gt; Map.&lt;string\Z boolean&gt;
      // bad hack: {a: string, b: boolean} =&gt; {a\Y string\Z b\Y boolean}
      let inner = matched[2]
        .replace(/&lt;.*?&gt;/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;))
        .replace(/{.*?}/g, (a)=&gt; a.replace(/,/g, &apos;\\Z&apos;).replace(/:/g, &apos;\\Y&apos;));
      let innerTypes = inner.split(&apos;,&apos;).map((v) =&gt; {
        v = v.trim().replace(/\\Z/g, &apos;,&apos;).replace(/\\Y/g, &apos;:&apos;);
        return this._buildTypeDocLinkHTML(v);
      });

      let html = `${this._buildDocLinkHTML(mainType, mainType)}&lt;${innerTypes.join(&apos;, &apos;)}&gt;`;
      return html;
    }

    if (typeName.indexOf(&apos;...&apos;) === 0) {
      typeName = typeName.replace(&apos;...&apos;, &apos;&apos;);
      return &apos;...&apos; + this._buildDocLinkHTML(typeName);
    } else {
      return this._buildDocLinkHTML(typeName);
    }
  }

  /**
   * build html link to identifier.
   * @param {string} longname - link to this.
   * @param {string} [text] - link text. default is name property of doc object.
   * @param {boolean} [inner=false] - if true, use inner link.
   * @param {string} [kind] - specify target kind property.
   * @returns {string} html of link.
   * @private
   */
  _buildDocLinkHTML(longname, text = null, inner = false, kind = null) {
    if (!longname) return &apos;&apos;;

    if (typeof longname !== &apos;string&apos;) throw new Error(JSON.stringify(longname));

    let doc = this._findByName(longname, kind)[0];

    if (!doc) {
      // if longname is HTML tag, not escape.
      if (longname.indexOf(&apos;&lt;&apos;) === 0) {
        return `&lt;span&gt;${longname}&lt;/span&gt;`;
      } else {
        return `&lt;span&gt;${escape(text || longname)}&lt;/span&gt;`;
      }
    }

    if (doc.kind === &apos;external&apos;) {
      text = doc.name;
      return `&lt;span&gt;&lt;a href=&quot;${doc.externalLink}&quot;&gt;${text}&lt;/a&gt;&lt;/span&gt;`;
    } else {
      text = escape(text || doc.name);
      let url = this._getURL(doc, inner);
      if (url) {
        return `&lt;span&gt;&lt;a href=&quot;${url}&quot;&gt;${text}&lt;/a&gt;&lt;/span&gt;`;
      } else {
        return `&lt;span&gt;${text}&lt;/span&gt;`;
      }
    }
  }

  /**
   * build html links to identifiers
   * @param {string[]} longnames - link to these.
   * @param {string} [text] - link text. default is name property of doc object.
   * @param {boolean} [inner=false] - if true, use inner link.
   * @param {string} [separator=&apos;\n&apos;] - used link separator.
   * @returns {string} html links.
   * @private
   */
  _buildDocsLinkHTML(longnames, text = null, inner = false, separator = &apos;\n&apos;) {
    if (!longnames) return &apos;&apos;;
    if (!longnames.length) return &apos;&apos;;

    let links = [];
    for (var longname of longnames) {
      if (!longname) continue;
      let link = this._buildDocLinkHTML(longname, text, inner);
      links.push(`&lt;li&gt;${link}&lt;/li&gt;`);
    }

    if (!links.length) return &apos;&apos;;

    return `&lt;ul&gt;${links.join(separator)}&lt;/ul&gt;`;
  }

  /**
   * build identifier signature html.
   * @param {DocObject} doc - target doc object.
   * @returns {string} signature html.
   * @private
   */
  _buildSignatureHTML(doc) {
    // call signature
    let callSignatures = [];
    if (doc.params) {
      for (let param of doc.params) {
        let paramName = param.name;
        if (paramName.indexOf(&apos;.&apos;) !== -1) continue;

        let types = [];
        for (let typeName of param.types) {
          types.push(this._buildTypeDocLinkHTML(typeName));
        }

        callSignatures.push(`${paramName}: ${types.join(&apos; | &apos;)}`);
      }
    }

    // return signature
    let returnSignatures = [];
    if (doc.return) {
      for (let typeName of doc.return.types) {
        returnSignatures.push(this._buildTypeDocLinkHTML(typeName));
      }
    }

    // type signature
    let typeSignatures = [];
    if (doc.type) {
      for (let typeName of doc.type.types) {
        typeSignatures.push(this._buildTypeDocLinkHTML(typeName));
      }
    }

    // callback is not need type. because type is always function.
    if (doc.kind === &apos;function&apos;) {
      typeSignatures = [];
    }

    let html = &apos;&apos;;
    if (callSignatures.length) {
      html = `(${callSignatures.join(&apos;, &apos;)})`;
    } else if ([&apos;function&apos;, &apos;method&apos;].includes(doc.kind)) {
      html = &apos;()&apos;;
    }
    if (returnSignatures.length) html = `${html}: ${returnSignatures.join(&apos; | &apos;)}`;
    if (typeSignatures.length) html = `${html}: ${typeSignatures.join(&apos; | &apos;)}`;

    return html;
  }

  /**
   * build properties output.
   * @param {ParsedParam[]} [properties=[]] - properties in doc object.
   * @param {string} title - output title.
   * @return {IceCap} built properties output.
   * @private
   */
  _buildProperties(properties = [], title = &apos;Properties:&apos;) {
    let ice = new IceCap(this._readTemplate(&apos;properties.html&apos;));

    ice.text(&apos;title&apos;, title);

    ice.loop(&apos;property&apos;, properties, (i, prop, ice)=&gt;{
      ice.autoDrop = false;
      ice.attr(&apos;property&apos;, &apos;data-depth&apos;, prop.name.split(&apos;.&apos;).length - 1);
      ice.text(&apos;name&apos;, prop.name);
      ice.attr(&apos;name&apos;, &apos;data-depth&apos;, prop.name.split(&apos;.&apos;).length - 1);
      ice.load(&apos;description&apos;, prop.description);

      let typeNames = [];
      for (var typeName of prop.types) {
        typeNames.push(this._buildTypeDocLinkHTML(typeName));
      }
      ice.load(&apos;type&apos;, typeNames.join(&apos; | &apos;));

      // appendix
      let appendix = [];
      if (prop.optional) {
        appendix.push(&apos;&lt;li&gt;optional&lt;/li&gt;&apos;);
      }
      if (&apos;defaultValue&apos; in prop) {
        appendix.push(`&lt;li&gt;default: ${prop.defaultValue}&lt;/li&gt;`);
      }
      if (typeof prop.nullable === &apos;boolean&apos;) {
        appendix.push(`&lt;li&gt;nullable: ${prop.nullable}&lt;/li&gt;`);
      }
      if (appendix.length) {
        ice.load(&apos;appendix&apos;, `&lt;ul&gt;${appendix.join(&apos;\n&apos;)}&lt;/ul&gt;`);
      } else {
        ice.text(&apos;appendix&apos;, &apos;&apos;);
      }
    });

    if (!properties || properties.length === 0) {
      ice.drop(&apos;properties&apos;);
    }

    return ice;
  }

  /**
   * build deprecated html.
   * @param {DocObject} doc - target doc object.
   * @returns {string} if doc is not deprecated, returns empty.
   * @private
   */
  _buildDeprecatedHTML(doc) {
    if (doc.deprecated) {
      let deprecated = [`this ${doc.kind} was deprecated.`];
      if (typeof doc.deprecated === &apos;string&apos;) deprecated.push(doc.deprecated);
      return deprecated.join(&apos; &apos;);
    } else {
      return &apos;&apos;;
    }
  }

  /**
   * build experimental html.
   * @param {DocObject} doc - target doc object.
   * @returns {string} if doc is not experimental, returns empty.
   * @private
   */
  _buildExperimentalHTML(doc) {
    if (doc.experimental) {
      let experimental = [`this ${doc.kind} is experimental.`];
      if (typeof doc.experimental === &apos;string&apos;) experimental.push(doc.experimental);
      return experimental.join(&apos; &apos;);
    } else {
      return &apos;&apos;;
    }
  }

  /**
   * build method of ancestor class link html.
   * @param {DocObject} doc - target doc object.
   * @returns {string} html link. if doc does not override ancestor method, returns empty.
   * @private
   */
  _buildOverrideMethod(doc) {
    let parentDoc = this._findByName(doc.memberof)[0];
    if (!parentDoc) return &apos;&apos;;
    if (!parentDoc._custom_extends_chains) return;

    let chains = [...parentDoc._custom_extends_chains].reverse();
    for (let longname of chains) {
      let superClassDoc = this._findByName(longname)[0];
      if (!superClassDoc) continue;

      let superMethodDoc = this._find({name: doc.name, memberof: superClassDoc.longname})[0];
      if (!superMethodDoc) continue;

      return this._buildDocLinkHTML(superMethodDoc.longname, `${superClassDoc.name}#${superMethodDoc.name}`, true);
    }
  }

  /**
   * build coverage html.
   * @param {CoverageObject} coverageObj - target coverage object.
   * @returns {string} html of coverage badge.
   * @private
   */
  _buildCoverageHTML(coverageObj) {
    let coverage = Math.floor(100 * coverageObj.actualCount / coverageObj.expectCount);
    let colorClass;
    if (coverage &lt; 50) {
      colorClass = &apos;esdoc-coverage-low&apos;;
    } else if (coverage &lt; 90) {
      colorClass = &apos;esdoc-coverage-middle&apos;;
    } else {
      colorClass = &apos;esdoc-coverage-high&apos;;
    }

    let html = `&lt;a href=&quot;https://esdoc.org&quot; class=&quot;esdoc-coverage-wrap&quot;&gt;
    &lt;span class=&quot;esdoc-coverage-label&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;esdoc-coverage-ratio ${colorClass}&quot;&gt;${coverage}%&lt;/span&gt;
    &lt;/a&gt;`;

    return html;
  }

  //_buildAuthorHTML(doc, separator = &apos;\n&apos;) {
  //  if (!doc.author) return &apos;&apos;;
  //
  //  var html = [];
  //  for (var author of doc.author) {
  //    var matched = author.match(/(.*?) *&lt;(.*?)&gt;/);
  //    if (matched) {
  //      var name = matched[1];
  //      var link = matched[2];
  //      if (link.indexOf(&apos;http&apos;) === 0) {
  //        html.push(`&lt;li&gt;&lt;a href=&quot;${link}&quot;&gt;${name}&lt;/a&gt;&lt;/li&gt;`)
  //      } else {
  //        html.push(`&lt;li&gt;&lt;a href=&quot;mailto:${link}&quot;&gt;${name}&lt;/a&gt;&lt;/li&gt;`)
  //      }
  //    } else {
  //      html.push(`&lt;li&gt;${author}&lt;/li&gt;`)
  //    }
  //  }
  //
  //  return `&lt;ul&gt;${html.join(separator)}&lt;/ul&gt;`;
  //}
}
</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.1.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
